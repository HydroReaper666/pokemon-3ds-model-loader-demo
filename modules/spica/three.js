((e,t)=>{const n=require("./model.js"),i=require("./shader.js"),a=require("./pica.js"),r=require("./texture.js"),s=require("./motion.js");n.prototype.toThreeObject=function(e,o){o||(o={});const c=[],l=this,u=new THREE.Object3D;c.push(u),u.name=this.bones[0].name;const p=new Map;u.skeleton=new THREE.Skeleton(this.bones.map(e=>{let t=p.get(e.parent);t||(t=u);let n=new THREE.Bone;n.name=e.name,n.scale.set(e.scale[0],e.scale[1],e.scale[2]),n.position.set(e.translation[0],e.translation[1],e.translation[2]),n.quaternion.setFromEuler(new THREE.Euler(e.rotation[0],e.rotation[1],e.rotation[2],"ZYX")),t.add(n),n.spicaMatrix=new THREE.Matrix4,n.spicaMatrixWorld=new THREE.Matrix4;let i=new THREE.Vector3(1,1,1),a=new THREE.Vector3(0,0,0);return n.updateMatrix=function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0,a.set(this.position.x*this.scale.x,this.position.y*this.scale.y,this.position.z*this.scale.z),this.spicaMatrix.compose(a,this.quaternion,i)},n.updateMatrixWorld=function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.parent.spicaMatrixWorld?(this.matrixWorld.multiplyMatrices(this.parent.spicaMatrixWorld,this.matrix),this.spicaMatrixWorld.multiplyMatrices(this.parent.spicaMatrixWorld,this.spicaMatrix)):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.spicaMatrixWorld.multiplyMatrices(this.parent.matrixWorld,this.spicaMatrix)),this.matrixWorldNeedsUpdate=!1,e=!0),this.children.forEach(t=>{t.updateMatrixWorld(e)})},n.updateMatrixWorld(!0),p.set(e.name,n),n}));const h=(s,l)=>{const u=s.textureCoordinates.map((i,l)=>{const u=(o.shiny?e.textures.shiny:e.textures.normal).files.filter(e=>t.is(e,r)&&e.name===i.name)[0],p=new Uint8Array(u.width*u.height*4);let h=u.getPixels(),m=0;for(;m<h.length;)p[m]=h[m+1],p[m+1]=h[m+2],p[m+2]=h[m+3],p[m+3]=h[m],m+=4;const f=new THREE.DataTexture(p,u.width,u.height,THREE.RGBAFormat);switch(c.push(f),f.flipY=!0,f.magFilter=i.magFilter.code===n.TextureMagnificationFilter.NEAREST?THREE.NearestFilter:THREE.LinearFilter,f.minFilter=i.minFilter.code===n.TextureMinificationFilter.NEAREST?THREE.NearestFilter:THREE.LinearFilter,f.name=i.name,f.needsUpdate=!0,i.wrap[0].code){case a.TextureWrap.CLAMP_TO_EDGE:case a.TextureWrap.CLAMP_TO_BORDER:f.wrapS=THREE.ClampToEdgeWrapping;break;case a.TextureWrap.REPEAT:f.wrapS=THREE.RepeatWrapping;break;case a.TextureWrap.MIRROR:f.wrapS=THREE.MirroredRepeatWrapping;break;default:throw new Error("Invalid texture wrap mode")}switch(i.wrap[1].code){case a.TextureWrap.CLAMP_TO_EDGE:case a.TextureWrap.CLAMP_TO_BORDER:f.wrapT=THREE.ClampToEdgeWrapping;break;case a.TextureWrap.REPEAT:f.wrapT=THREE.RepeatWrapping;break;case a.TextureWrap.MIRROR:f.wrapT=THREE.MirroredRepeatWrapping;break;default:throw new Error("Invalid texture wrap mode")}return f.offset.set(-i.translation[0],-i.translation[1]),f.repeat.set(i.scale[0],i.scale[1]),f.rotation=i.rotation,f.repeat.set(s.pica.shader.vertex.floats[1+3*l].x,s.pica.shader.vertex.floats[2+3*l].y),f.offset.set(-s.pica.shader.vertex.floats[1+3*l].w/s.pica.shader.vertex.floats[1+3*l].x,-s.pica.shader.vertex.floats[2+3*l].w/s.pica.shader.vertex.floats[2+3*l].y),0!==f.rotation&&t.warn("Texture rotation currently not supported"),f.matrix.setUvTransform(f.offset.x*f.repeat.x,f.offset.y*f.repeat.y,f.repeat.x,f.repeat.y,f.rotation,0,0),f}),p={},h={};s.lightingLUTs.filter(e=>0!==e).forEach(e=>{let t=this.lightingLUTs.filter(t=>t.hashID===e)[0];if(!t)throw new Error("Lighting LUT not found "+e);let n=new Uint8Array(3*t.pica.lightingLUTs.data.length),i=0;for(;i<t.pica.lightingLUTs.data.length;)n[3*i]=Math.round(255*t.pica.lightingLUTs.data[i]),n[3*i+1]=Math.round(255*t.pica.lightingLUTs.data[i]),n[3*i+2]=Math.round(255*t.pica.lightingLUTs.data[i]),++i;let r=new THREE.DataTexture(n,t.pica.lightingLUTs.data.length,1,THREE.RGBFormat);switch(c.push(r),t.name&&(r.name=t.name),r.flipY=!0,r.needsUpdate=!0,t.pica.lightingLUTs.type.code){case a.LUTType.DIST_0:p.dist0=!0,h.lutDist0=r;break;case a.LUTType.DIST_1:p.dist1=!0,h.lutDist1=r;break;case a.LUTType.FRESNEL:p.fresnel=!0,h.lutFresnel=r;break;case a.LUTType.REFLECT_R:p.reflectR=!0,h.lutReflectR=r;break;case a.LUTType.REFLECT_G:p.reflectG=!0,h.lutReflectG=r;break;case a.LUTType.REFLECT_B:p.reflectB=!0,h.lutReflectB=r;break;default:throw new Error("Unsupported LUT type")}});let m=e.model.files[2].files.filter(e=>t.is(e,i)&&e.name===s.vertexShader)[0],f=e.model.files[2].files.filter(e=>t.is(e,i)&&e.name===s.fragmentShader)[0],d=m.describe(!0,s,p),E=f.describe(!0,s,p);t("shader#"+f.name).length>0&&(t.celebr("Using inline fragment shader "+f.name),E=t("shader#"+f.name).text()),t("shader#"+m.name).length>0&&(t.celebr("Using inline vertex shader "+m.name),d=t("shader#"+m.name).text());let T=[];for(;T.length<96;){let e=new THREE.Vector4(0,0,0,0);if(s.pica.shader&&s.pica.shader.vertex&&s.pica.shader.vertex.floats){let t=s.pica.shader.vertex.floats[T.length];t&&e.set(t.x,t.y,t.z,t.w)}if(m.pica.shader&&m.pica.shader.vertex.floats){let t=m.pica.shader.vertex.floats[T.length];t&&e.set(t.x,t.y,t.z,t.w)}T.push(e)}if(T[82].set(s.rimPower,s.rimScale,s.phongPower,s.phongScale),s.shaderParameters){let e=s.shaderParameters;T[85].set(e[0],e[1],e[2],e[3])}let g=[new THREE.Vector4(s.constantColors[0].r/255,s.constantColors[0].g/255,s.constantColors[0].b/255,s.constantColors[0].a/255),new THREE.Vector4(s.constantColors[1].r/255,s.constantColors[1].g/255,s.constantColors[1].b/255,s.constantColors[1].a/255),new THREE.Vector4(s.constantColors[2].r/255,s.constantColors[2].g/255,s.constantColors[2].b/255,s.constantColors[2].a/255),new THREE.Vector4(s.constantColors[3].r/255,s.constantColors[3].g/255,s.constantColors[3].b/255,s.constantColors[3].a/255),new THREE.Vector4(s.constantColors[4].r/255,s.constantColors[4].g/255,s.constantColors[4].b/255,s.constantColors[4].a/255),new THREE.Vector4(s.constantColors[5].r/255,s.constantColors[5].g/255,s.constantColors[5].b/255,s.constantColors[5].a/255)],x=[g[s.constantAssignments[0]],g[s.constantAssignments[1]],g[s.constantAssignments[2]],g[s.constantAssignments[3]],g[s.constantAssignments[4]],g[s.constantAssignments[5]]],v=!1,R=!1,y=!1,b=!1,A=!1;if(s.textureCoordinates[0])switch(s.textureCoordinates[0].mappingType.code){case n.TextureMappingType.UV:v=!0}if(s.textureCoordinates[1])switch(s.textureCoordinates[1].mappingType.code){case n.TextureMappingType.UV:R=!0;break;case n.TextureMappingType.CAMERA_SPHERE:b=!0}if(s.textureCoordinates[2])switch(s.textureCoordinates[2].mappingType.code){case n.TextureMappingType.UV:y=!0;break;case n.TextureMappingType.CAMERA_SPHERE:A=!0}const w=new THREE.RawShaderMaterial({uniforms:{needColor:{type:"b",value:!0},hasUVMap:{type:"b",value:v},hasUVMap2:{type:"b",value:R},hasUVMap3:{type:"b",value:y},needUVMap2SphereReflection:{type:"b",value:b},needUVMap3SphereReflection:{type:"b",value:A},needLightSpecular:{type:"b",value:!0},needViewSpecular:{type:"b",value:!0},needDiffuse:{type:"b",value:!0},hasTangent:{type:"b",value:!0===l.hasTangent},hasBone:{type:"b",value:!0===l.hasBoneIndex},hasBoneW:{type:"b",value:!0===l.hasBoneW},emission:{type:"v4",value:new THREE.Vector4(s.emissionColor.r/255,s.emissionColor.g/255,s.emissionColor.b/255,s.emissionColor.a/255)},ambient:{type:"v4",value:new THREE.Vector4(s.ambientColor.r/255,s.ambientColor.g/255,s.ambientColor.b/255,s.ambientColor.a/255)},diffuse:{type:"v4",value:new THREE.Vector4(s.diffuseColor.r/255,s.diffuseColor.g/255,s.diffuseColor.b/255,s.diffuseColor.a/255)},speculars:{type:"v4v",value:[new THREE.Vector4(s.specularColors[0].r/255,s.specularColors[0].g/255,s.specularColors[0].b/255,s.specularColors[0].a/255),new THREE.Vector4(s.specularColors[1].r/255,s.specularColors[1].g/255,s.specularColors[1].b/255,s.specularColors[1].a/255)]},constants:{type:"v4v",value:x},map:{type:"t",value:u[0]},map2:{type:"t",value:u[1]},map3:{type:"t",value:u[2]},lutDist0:{type:"t",value:h.lutDist0},lutDist1:{type:"t",value:h.lutDist1},lutFresnel:{type:"t",value:h.lutFresnel},lutReflectR:{type:"t",value:h.lutReflectR},lutReflectG:{type:"t",value:h.lutReflectG},lutReflectB:{type:"t",value:h.lutReflectB},environmentAmbient:{type:"v4",value:new THREE.Vector4(0,0,0,0)},lightPositions:{type:"v3v",value:[new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0)]},lightDirections:{type:"v3v",value:[new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,0)]},lightAmbients:{type:"v4v",value:[new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0)]},lightDiffuses:{type:"v4v",value:[new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0)]},lightSpeculars:{type:"v4v",value:[new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0),new THREE.Vector4(0,0,0,0)]},lightDirectionals:{type:"bv",value:[!1,!1,!1]},lightsCount:{type:"i",value:0},vectors:{type:"v4v",value:T},uvVectors:{type:"v4v",value:[T[0],T[1],T[2],T[3],T[4],T[5],T[6],T[7],T[8],T[9]]}},vertexShader:d,fragmentShader:E});switch(c.push(w),w.name=s.name,s.pica.faceCulling.code){case a.FaceCulling.BACK_FACE:w.side=THREE.FrontSide;break;case a.FaceCulling.FRONT_FACE:w.side=THREE.BackSide;break;case a.FaceCulling.NEVER:w.side=THREE.DoubleSide;break;default:throw new Error("Invalid face culling state")}w.spica=!0,w.spicaConstant0=g[0],w.spicaConstant1=g[1],w.spicaConstant2=g[2],w.spicaConstant3=g[3],w.spicaConstant4=g[4],w.spicaConstant5=g[5],w.spicaTexture1=u[0],w.spicaTexture2=u[1],w.spicaTexture3=u[2],w.spicaTextureNames=s.textureCoordinates.map(e=>e.name),w.spicaVertexShaderName=s.vertexShader,w.spicaVertexShaderFileName=m.fileName,w.spicaVertexShaderHasGeometryCodes=m.pica.shader.geometry&&!t.is.nil(m.pica.shader.geometry.entryPoint),w.spicaFragmentShaderName=s.fragmentShader,w.spicaFragmentShaderFileName=f.fileName,w.spicaAlphaTest=s.pica.rendering.alphaTest.enabled,w.spicaStencilTest=s.pica.rendering.stencilTest.enabled,w.transparent=!0;const C=e=>{switch(e){case a.BlendFunctionOperation.ZERO:return THREE.ZeroFactor;case a.BlendFunctionOperation.ONE:return THREE.OneFactor;case a.BlendFunctionOperation.SOURCE_COLOR:return THREE.SrcColorFactor;case a.BlendFunctionOperation.ONE_MINUS_SOURCE_COLOR:return THREE.OneMinusSrcColorFactor;case a.BlendFunctionOperation.DESTINATION_COLOR:return THREE.DstColorFactor;case a.BlendFunctionOperation.ONE_MINUS_DESTINATION_COLOR:return THREE.OneMinusDstColorFactor;case a.BlendFunctionOperation.SOURCE_ALPHA:return THREE.SrcAlphaFactor;case a.BlendFunctionOperation.ONE_MINUS_SOURCE_ALPHA:return THREE.OneMinusSrcAlphaFactor;case a.BlendFunctionOperation.DESTINATION_ALPHA:return THREE.DstAlphaFactor;case a.BlendFunctionOperation.ONE_MINUS_DESTINATION_ALPHA:return THREE.OneMinusDstAlphaFactor;case a.BlendFunctionOperation.SOURCE_ALPHA_SATURATE:return THREE.SrcAlphaSaturateFactor;case a.BlendFunctionOperation.CONSTANT_COLOR:case a.BlendFunctionOperation.ONE_MINUS_CONSTANT_COLOR:case a.BlendFunctionOperation.CONSTANT_ALPHA:case a.BlendFunctionOperation.ONE_MINUS_CONSTANT_ALPHA:throw new Error("Invalid constant blending function");default:throw new Error("Invalid blending function")}},H=e=>{switch(e){case a.BlendEquation.ADD:return THREE.AddEquation;case a.BlendEquation.SUBTRACT:return THREE.SubtractEquation;case a.BlendEquation.REVERSE_SUBTRACT:return THREE.ReverseSubtractEquation;case a.BlendEquation.MIN:return THREE.MinEquation;case a.BlendEquation.MAX:return THREE.MaxEquation;default:throw new Error("Invalid blending equation")}};switch(w.blendDst=C(s.pica.rendering.blendFunction.colorDestinationFunction.code),w.blendDstAlpha=C(s.pica.rendering.blendFunction.alphaDestinationFunction.code),w.blendEquation=H(s.pica.rendering.blendFunction.colorEquation.code),w.blendEquationAlpha=H(s.pica.rendering.blendFunction.alphaEquation.code),w.blendSrc=C(s.pica.rendering.blendFunction.colorSourceFunction.code),w.blendSrcAlpha=C(s.pica.rendering.blendFunction.alphaSourceFunction.code),w.blending=THREE.CustomBlending,w.premultipliedAlpha=!0,w.spicaStencil={enabled:s.pica.rendering.stencilTest.enabled,buffer:s.pica.rendering.stencilTest.bufferMask,test:s.pica.rendering.stencilTest.testFunction,reference:s.pica.rendering.stencilTest.reference,mask:s.pica.rendering.stencilTest.mask,failed:s.pica.rendering.stencilOperation.failOperation,zFailed:s.pica.rendering.stencilOperation.zFailOperation,zPassed:s.pica.rendering.stencilOperation.zPassOperation},w.spicaLayer=s.renderLayer,w.spicaPriority=s.renderPriority,w.spicaLUTs=s.lightingLUTs,w.depthTest=s.pica.depth.enabled,s.pica.depth.colorMask.depthFunction.code){case a.TestFunction.ALWAYS:w.depthFunc=THREE.AlwaysDepth;break;case a.TestFunction.NEVER:w.depthFunc=THREE.NeverDepth;break;case a.TestFunction.NOT_EQUAL_TO:w.depthFunc=THREE.NotEqualDepth;break;case a.TestFunction.LESS_THAN:w.depthFunc=THREE.LessDepth;break;case a.TestFunction.LESS_THAN_OR_EQUAL_TO:w.depthFunc=THREE.LessEqualDepth;break;case a.TestFunction.GREATER_THAN:w.depthFunc=THREE.GreaterDepth;break;case a.TestFunction.GREATER_THAN_OR_EQUAL_TO:w.depthFunc=THREE.GreaterEqualDepth;break;case a.TestFunction.EQUAL_TO:throw new Error("Not supported EQUAL_TO depth tester");default:throw new Error("Invalid depth tester")}return w.depthWrite=s.pica.depth.colorMask.depthWrite,w},m=e=>{let t=new THREE.ShaderMaterial({uniforms:{outlineOffset:{type:"f",value:1}},vertexShader:["uniform float outlineOffset;","#include <skinning_pars_vertex>","void main() {","    #include <begin_vertex>","    #include <skinbase_vertex>","    #include <skinning_vertex>","    vec2 unit = normalize((projectionMatrix * modelViewMatrix * vec4(normal, 0.0)).xyz).xy;","    vec2 advance = unit * outlineOffset * distance(cameraPosition, transformed) / 600.0;","    gl_Position = (projectionMatrix * modelViewMatrix * vec4(transformed, 1.0)) + vec4(advance.x, advance.y, 0.0, 0.0));","}"].join("\n"),fragmentShader:["void main() {","    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","}"].join("\n")});return t.side=THREE.BackSide,t.skinning=!0,t.spicaLayer=e.renderLayer,t.spicaPriority=e.renderPriority+.5,t},f=[];return this.meshes.forEach(n=>{n.submeshes.forEach((r,s)=>{let o=this.materials.filter(e=>e.name===r.material)[0].vertexShader,p=!t.is.nil(e.model.files[2].files.filter(e=>t.is(e,i)&&e.name===o)[0].pica.shader.geometry.entryPoint);const d=new THREE.BufferGeometry;c.push(d),d.name=n.name+(s+1);const E={hasBoneW:n.boneIndicesPerVertex>=4};if(r.vertices.attributes.forEach(e=>{switch(e.name.code){case a.AttributeName.POSITION:E.hasPosition=!e.fixed||e.value;break;case a.AttributeName.NORMAL:E.hasNormal=!e.fixed||e.value;break;case a.AttributeName.TANGENT:E.hasTangent=!e.fixed||e.value;break;case a.AttributeName.COLOR:E.hasColor=!e.fixed||e.value;break;case a.AttributeName.TEXTURE_COORDINATE_0:E.hasTextureCoordinate0=!e.fixed||e.value;break;case a.AttributeName.TEXTURE_COORDINATE_1:E.hasTextureCoordinate1=!e.fixed||e.value;break;case a.AttributeName.TEXTURE_COORDINATE_2:E.hasTextureCoordinate2=!e.fixed||e.value;break;case a.AttributeName.BONE_INDEX:E.hasBoneIndex=!e.fixed||e.value;break;case a.AttributeName.BONE_WEIGHT:E.hasBoneWeight=!e.fixed||e.value}}),E.hasPosition){let e=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((t,n)=>{let i=!0===E.hasPosition?t.position:E.hasPosition;e[4*n]=i[0],e[4*n+1]=i[1],e[4*n+2]=i[2],e[4*n+3]=1}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("position",new THREE.Float32BufferAttribute(e,4))}if(E.hasNormal){let e=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((t,n)=>{let i=!0===E.hasNormal?t.normal:E.hasNormal;e[4*n]=i[0],e[4*n+1]=i[1],e[4*n+2]=i[2]}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("normal",new THREE.Float32BufferAttribute(e,4))}if(E.hasTangent){let e=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((t,n)=>{let i=!0===E.hasTangent?t.tangent:E.hasTangent;e[4*n]=i[0],e[4*n+1]=i[1],e[4*n+2]=i[2]}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("tangent",new THREE.Float32BufferAttribute(e,4))}if(E.hasColor){let e=new Uint8Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((t,n)=>{let i=!0===E.hasColor?t.color:E.hasColor;e[4*n]=i[1],e[4*n+1]=i[2],e[4*n+2]=i[3],e[4*n+3]=i[0]}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("color",new THREE.Uint8BufferAttribute(e,4))}if(E.hasTextureCoordinate0){let e=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((t,n)=>{let i=!0===E.hasTextureCoordinate0?t.textures[0]:E.hasTextureCoordinate0;e[4*n]=i[0],e[4*n+1]=i[1]}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("uv",new THREE.Float32BufferAttribute(e,4))}if(E.hasTextureCoordinate1){let e=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((t,n)=>{let i=!0===E.hasTextureCoordinate1?t.textures[1]:E.hasTextureCoordinate1;e[4*n]=i[0],e[4*n+1]=i[1]}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("uv2",new THREE.Float32BufferAttribute(e,4))}if(E.hasTextureCoordinate2){let e=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((t,n)=>{let i=!0===E.hasTextureCoordinate2?t.textures[2]:E.hasTextureCoordinate2;e[4*n]=i[0],e[4*n+1]=i[1]}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("uv3",new THREE.Float32BufferAttribute(e,4))}if(E.hasBoneIndex){const e=new Float32Array(4*r.vertices.count*(p?4:1)),t=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((n,i)=>{let a=!0===E.hasBoneIndex?n.boneIndices:E.hasBoneIndex;isFinite(a[0])?(e[4*i]=r.boneIndices[a[0]],t[4*i]=a[0]):(e[4*i]=NaN,t[4*i]=NaN),isFinite(a[1])?(e[4*i+1]=r.boneIndices[a[1]],t[4*i+1]=a[1]):(e[4*i+1]=NaN,t[4*i+1]=NaN),isFinite(a[2])?(e[4*i+2]=r.boneIndices[a[2]],t[4*i+2]=a[2]):(e[4*i+2]=NaN,t[4*i+2]=NaN),isFinite(a[3])?(e[4*i+3]=r.boneIndices[a[3]],t[4*i+3]=a[3]):(e[4*i+3]=NaN,t[4*i+3]=NaN)}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count),t.copyWithin(4*r.vertices.count,0,4*r.vertices.count),t.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),t.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("skinIndex",new THREE.Float32BufferAttribute(e,4)),d.addAttribute("boneIndex",new THREE.Float32BufferAttribute(t,4))}if(E.hasBoneWeight){const e=new Float32Array(4*r.vertices.count*(p?4:1)),t=new Float32Array(4*r.vertices.count*(p?4:1));r.vertices.data.forEach((n,i)=>{let a=!0===E.hasBoneWeight?n.boneWeights:E.hasBoneWeight;e[4*i]=a[0]/255,t[4*i]=a[0],e[4*i+1]=a[1]/255,t[4*i+1]=a[1],e[4*i+2]=a[2]/255,t[4*i+2]=a[2],e[4*i+3]=a[3]/255,t[4*i+3]=a[3]}),p&&(e.copyWithin(4*r.vertices.count,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),e.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count),t.copyWithin(4*r.vertices.count,0,4*r.vertices.count),t.copyWithin(4*r.vertices.count*2,0,4*r.vertices.count),t.copyWithin(4*r.vertices.count*3,0,4*r.vertices.count)),d.addAttribute("skinWeight",new THREE.Float32BufferAttribute(e,4)),d.addAttribute("boneWeight",new THREE.Float32BufferAttribute(t,4))}if(p){const e=new Float32Array(4*r.vertices.count*4);e.fill(0,0,4*r.vertices.count),e.fill(1,4*r.vertices.count,4*r.vertices.count*2),e.fill(2,4*r.vertices.count*2,4*r.vertices.count*3),e.fill(3,4*r.vertices.count*3,4*r.vertices.count*4),d.addAttribute("geometryIndex",new THREE.Float32BufferAttribute(e,4))}const T=new Uint16Array(r.vertexIndices.count*(p?6:1));r.vertexIndices.data.forEach((e,t)=>{if(p){let n=r.vertices.data.length;T[6*t]=e+0*n,T[6*t+1]=e+n,T[6*t+2]=e+2*n,T[6*t+3]=e+n,T[6*t+4]=e+2*n,T[6*t+5]=e+3*n}else T[t]=e}),d.setIndex(new THREE.Uint16BufferAttribute(T,1));let g=this.materials.filter(e=>e.name===r.material)[0],x=h(g,E),v=m(g),R=null,y=null;E.hasBoneIndex?(R=new THREE.SkinnedMesh(d,x),y=new THREE.SkinnedMesh(d,v)):(R=new THREE.Mesh(d,x),y=new THREE.Mesh(d,v)),f.push(R),R.name=n.name+(s+1),x.spicaTexture1&&(R.spicaTexture1Offset=x.spicaTexture1.offset,R.spicaTexture1Rotation=x.spicaTexture1.rotation,R.spicaTexture1Repeat=x.spicaTexture1.repeat),x.spicaTexture2&&(R.spicaTexture2Offset=x.spicaTexture2.offset,R.spicaTexture2Rotation=x.spicaTexture2.rotation,R.spicaTexture2Repeat=x.spicaTexture2.repeat),x.spicaTexture3&&(R.spicaTexture3Offset=x.spicaTexture3.offset,R.spicaTexture3Rotation=x.spicaTexture3.rotation,R.spicaTexture3Repeat=x.spicaTexture3.repeat),R.spicaConstant0=x.spicaConstant0,R.spicaConstant1=x.spicaConstant1,R.spicaConstant2=x.spicaConstant2,R.spicaConstant3=x.spicaConstant3,R.spicaConstant4=x.spicaConstant4,R.spicaConstant5=x.spicaConstant5;let b="Default"===g.vertexShader;R.onBeforeRender=function(e,t,n,i,s,o){if(s.spica){let e=n.projectionMatrix,i=n.matrixWorldInverse,a=R.skeleton.boneMatrices,o=s.uniforms.vectors.value;s.uniforms.map.value&&(s.uniforms.map.value.rotation=R.spicaTexture1Rotation,s.uniforms.map.value.matrix.setUvTransform(s.uniforms.map.value.repeat.x*s.uniforms.map.value.offset.x,s.uniforms.map.value.repeat.y*s.uniforms.map.value.offset.y,s.uniforms.map.value.repeat.x,s.uniforms.map.value.repeat.y,s.uniforms.map.value.rotation,0,0),o[1].set(s.uniforms.map.value.matrix.elements[0],s.uniforms.map.value.matrix.elements[3],0,s.uniforms.map.value.matrix.elements[6]),o[2].set(s.uniforms.map.value.matrix.elements[1],s.uniforms.map.value.matrix.elements[4],0,s.uniforms.map.value.matrix.elements[7]),o[3].set(s.uniforms.map.value.matrix.elements[2],s.uniforms.map.value.matrix.elements[5],s.uniforms.map.value.matrix.elements[8],0)),s.uniforms.map2.value&&(s.uniforms.map2.value.rotation=R.spicaTexture2Rotation,s.uniforms.map2.value.matrix.setUvTransform(s.uniforms.map2.value.repeat.x*s.uniforms.map2.value.offset.x,s.uniforms.map2.value.repeat.y*s.uniforms.map2.value.offset.y,s.uniforms.map2.value.repeat.x,s.uniforms.map2.value.repeat.y,s.uniforms.map2.value.rotation,0,0),o[4].set(s.uniforms.map2.value.matrix.elements[0],s.uniforms.map2.value.matrix.elements[3],0,s.uniforms.map2.value.matrix.elements[6]),o[5].set(s.uniforms.map2.value.matrix.elements[1],s.uniforms.map2.value.matrix.elements[4],0,s.uniforms.map2.value.matrix.elements[7]),o[6].set(s.uniforms.map2.value.matrix.elements[2],s.uniforms.map2.value.matrix.elements[5],s.uniforms.map2.value.matrix.elements[8],0)),s.uniforms.map3.value&&(s.uniforms.map3.value.rotation=R.spicaTexture3Rotation,s.uniforms.map3.value.matrix.setUvTransform(s.uniforms.map3.value.repeat.x*s.uniforms.map3.value.offset.x,s.uniforms.map3.value.repeat.y*s.uniforms.map3.value.offset.y,s.uniforms.map3.value.repeat.x,s.uniforms.map3.value.repeat.y,s.uniforms.map3.value.rotation,0,0),o[7].set(s.uniforms.map3.value.matrix.elements[0],s.uniforms.map3.value.matrix.elements[3],0,s.uniforms.map3.value.matrix.elements[6]),o[8].set(s.uniforms.map3.value.matrix.elements[1],s.uniforms.map3.value.matrix.elements[4],0,s.uniforms.map3.value.matrix.elements[7]));let c=[1,1,1],p=u;for(;p;)c[0]*=p.scale.x,c[1]*=p.scale.y,c[2]*=p.scale.z,p=p.parent;o[81].set(c[0],c[1],c[2],1);let h=0;for(;h<20&&h<r.boneIndices.length;){let e=16*r.boneIndices[h];o[10+3*h].set(a[e],a[e+4],a[e+8],a[e+12]),o[11+3*h].set(a[e+1],a[e+5],a[e+9],a[e+13]),o[12+3*h].set(a[e+2],a[e+6],a[e+10],a[e+14]),++h}let m=t.children.filter(e=>e.isDirectionalLight)[0];if(m){let e=new THREE.Vector4(0,0,0,1);e.applyMatrix4(m.target.matrixWorld);let t=new THREE.Vector4(0,0,0,1);t.applyMatrix4(m.matrixWorld);let n=new THREE.Vector4(t.x-e.x,t.y-e.y,t.z-e.z,0);o[83].set(n.x,n.y,n.z,0)}else o[83].set(0,1,0,0);b?m?o[84].set(m.color.r,m.color.g,m.color.b,m.intensity):o[84].set(1,1,1,0):o[84].set((l.boundingBox.max[0]-l.boundingBox.min[0])*u.scale.x,(l.boundingBox.max[2]-l.boundingBox.min[2])*u.scale.z,l.boundingBox.min[1]*u.scale.y,l.boundingBox.max[1]*u.scale.y),o[86].set(e.elements[0],e.elements[4],e.elements[8],e.elements[12]),o[87].set(e.elements[1],e.elements[5],e.elements[9],e.elements[13]),o[88].set(e.elements[2],e.elements[6],e.elements[10],e.elements[14]),o[89].set(e.elements[3],e.elements[7],e.elements[11],e.elements[15]),o[90].set(i.elements[0],i.elements[4],i.elements[8],i.elements[12]),o[91].set(i.elements[1],i.elements[5],i.elements[9],i.elements[13]),o[92].set(i.elements[2],i.elements[6],i.elements[10],i.elements[14]);let f=t.children.filter(e=>e.isAmbientLight)[0];f&&s.uniforms.environmentAmbient.value.set(f.color.r,f.color.g,f.color.b,f.intensity);let d=t.children.filter(e=>e.isLight&&!e.isAmbientLight).slice(0,3);for(h=0;h<d.length;){if(s.uniforms.lightDirectionals.value[h]=d[h].isDirectionalLight,s.uniforms.lightDirectionals.value[h]){let e=new THREE.Vector4(0,0,0,1);e.applyMatrix4(d[h].target.matrixWorld);let t=new THREE.Vector4(0,0,0,1);t.applyMatrix4(d[h].matrixWorld);let i=new THREE.Vector4(t.x-e.x,t.y-e.y,t.z-e.z,0);i.applyMatrix4(n.matrixWorldInverse),s.uniforms.lightPositions.value[h].set(i.x,i.y,i.z,0),s.uniforms.lightDirections.value[h].set(i.x,i.y,i.z,0)}else s.uniforms.lightPositions.value[h].set(d[h].position.x,d[h].position.y,d[h].position.z),s.uniforms.lightDirections.value[h].set(d[h].position.x,d[h].position.y,d[h].position.z);s.uniforms.lightAmbients.value[h].set(d[h].color.r,d[h].color.g,d[h].color.b,d[h].intensity),s.uniforms.lightDiffuses.value[h].set(1,1,1,d[h].intensity),s.uniforms.lightSpeculars.value[2*h].set(1,1,1,d[h].intensity),s.uniforms.lightSpeculars.value[2*h+1].set(1,1,1,d[h].intensity),++h}s.uniforms.lightsCount.value=d.length}if(s.spicaStencil&&s.spicaStencil.enabled){const t=t=>{switch(t){case a.StencilOperationAction.KEEP:return e.context.KEEP;case a.StencilOperationAction.ZERO:return e.context.ZERO;case a.StencilOperationAction.REPLACE:return e.context.REPLACE;case a.StencilOperationAction.INCREMENT:return e.context.INCR;case a.StencilOperationAction.DECREMENT:return e.context.DECR;case a.StencilOperationAction.INVERT:return e.context.INVERT;case a.StencilOperationAction.INCREMENT_WRAP:return e.context.INCR_WRAP;case a.StencilOperationAction.DECREMENT_WRAP:return e.context.DECR_WRAP;default:throw new Error("Invalid stencil action")}},n=t=>{switch(t){case a.TestFunction.NEVER:return e.context.NEVER;case a.TestFunction.ALWAYS:return e.context.ALWAYS;case a.TestFunction.EQUAL_TO:return e.context.EQUAL;case a.TestFunction.NOT_EQUAL_TO:return e.context.NOTEQUAL;case a.TestFunction.LESS_THAN:return e.context.LESS;case a.TestFunction.LESS_THAN_OR_EQUAL_TO:return e.context.LEQUAL;case a.TestFunction.GREATER_THAN:return e.context.GREATER;case a.TestFunction.GREATER_THAN_OR_EQUAL_TO:return e.context.GEQUAL;default:throw new Error("Invalid stencil test function")}};e.state.buffers.stencil.setTest(!0),e.state.buffers.stencil.setOp(t(s.spicaStencil.failed.code),t(s.spicaStencil.zFailed.code),t(s.spicaStencil.zPassed.code)),e.state.buffers.stencil.setFunc(n(s.spicaStencil.test.code),s.spicaStencil.reference,s.spicaStencil.mask),e.state.buffers.stencil.setMask(s.spicaStencil.buffer)}},R.onAfterRender=function(e,t,n,i,a){a.spicaStencil&&a.spicaStencil.enabled&&e.state.buffers.stencil.setTest(!1)}})}),f.reverse(),f.sort((e,t)=>{let n=e.material.spicaLayer-t.material.spicaLayer;return 0!==n?n:e.material.spicaPriority-t.material.spicaPriority}),f.forEach((e,t)=>{e.renderOrder=t+1}),f.forEach(e=>{u.add(e),e.updateMatrixWorld(!0),e.isSkinnedMesh&&e.bind(u.skeleton)}),u.animations=[],[[e.motions.fighting.files,"Fighting"],[e.motions.pet.files,"Pet"],[e.motions.map.files,"Map"],[e.motions.acting.files,"Acting"]].forEach(([e,n])=>{e.forEach((e,i)=>{if(!t.is(e,s))return;const a=n+"Action"+(i+1),r=[];e.skeletal&&e.skeletal.transforms.forEach(t=>{let n=t.bone,i=this.bones.filter(e=>e.name===n)[0];if(!i)return;[["scale","scale"],["rotation","quaternion"],["translation","position"]].forEach(([a,o])=>{if(0===t[a+"X"].length&&0===t[a+"Y"].length&&0===t[a+"Z"].length)return;const c=[];["x","y","z"].forEach((n,r)=>{const l=a+n.toUpperCase();if(t[l].length>0&&0!==t[l][0].frame)throw new Error("Incorrect initial frame");let u=0,p=0;for(;p<=e.frames;){let h=p<e.frames?2:1,m=0;for(;m<h;){let e=2*p+m;c[e]||(c[e]={}),t[l].length>0?(c[e][n]=s.interpolate(t[l][u],t[l][u+1],p+m/2),u<t[l].length-1&&t[l][u+1].frame===p&&++u):c[e][n]="quaternion"===o?0:i[a][r%3],++m}++p}});let l=[];c.forEach((e,t)=>{l.push(t/s.FPS/2)});let u=[],p=[[],[],[],[]];c.forEach(e=>{if("quaternion"===o){let n=new THREE.Quaternion;if(t.axisAngle){let t=new THREE.Vector3(e.x,e.y,e.z),i=2*t.length();t.normalize(),n.setFromAxisAngle(t,i)}else{let t=new THREE.Euler(e.x,e.y,e.z,"ZYX");n.setFromEuler(t)}u.push(n.x,n.y,n.z,n.w),p[0].push(n.x),p[1].push(n.y),p[2].push(n.z),p[3].push(n.w)}else if("position"===o)u.push(e.x,e.y,e.z),p[0].push(e.x),p[1].push(e.y),p[2].push(e.z);else{if("scale"!==o)throw new Error("Unknown keys");u.push(e.x,e.y,e.z),p[0].push(e.x),p[1].push(e.y),p[2].push(e.z)}});let h=null;if("quaternion"===o){(h=new THREE.QuaternionKeyframeTrack(`.bones[${n}].${o}`,l,u)).spicaConstant=t.rotationX.isConstant&&t.rotationY.isConstant&&t.rotationZ.isConstant;let e=new THREE.Quaternion;e.setFromEuler(new THREE.Euler(i[a][0],i[a][1],i[a][2],"ZYX")),h.spicaOrigin=[e.x,e.y,e.z,e.w],r.push(h)}else"position"===o?(t.translationX.length>0&&((h=new THREE.NumberKeyframeTrack(`.bones[${n}].${o}[x]`,l,p[0])).spicaConstant=t.translationX.isConstant,h.spicaOrigin=[i[a][0]],r.push(h)),t.translationY.length>0&&((h=new THREE.NumberKeyframeTrack(`.bones[${n}].${o}[y]`,l,p[1])).spicaConstant=t.translationX.isConstant,h.spicaOrigin=[i[a][1]],r.push(h)),t.translationZ.length>0&&((h=new THREE.NumberKeyframeTrack(`.bones[${n}].${o}[z]`,l,p[2])).spicaConstant=t.translationX.isConstant,h.spicaOrigin=[i[a][2]],r.push(h))):"scale"===o&&(t.scaleX.length>0&&((h=new THREE.NumberKeyframeTrack(`.bones[${n}].${o}[x]`,l,p[0])).spicaConstant=t.translationX.isConstant,h.spicaOrigin=[i[a][0]],r.push(h)),t.scaleY.length>0&&((h=new THREE.NumberKeyframeTrack(`.bones[${n}].${o}[y]`,l,p[1])).spicaConstant=t.translationX.isConstant,h.spicaOrigin=[i[a][1]],r.push(h)),t.scaleZ.length>0&&((h=new THREE.NumberKeyframeTrack(`.bones[${n}].${o}[z]`,l,p[2])).spicaConstant=t.translationX.isConstant,h.spicaOrigin=[i[a][2]],r.push(h)))})}),e.material&&e.material.transforms.forEach(n=>{let i=this.materials.filter(e=>e.name===n.material)[0];if(!i)return void t.warn("Material not found for animations");let a=[];this.meshes.forEach(e=>{e.submeshes.forEach((r,s)=>{if(r.material===n.material){if(n.textureIndex>=i.textureCoordinates.length)return void t.warn("Texture not found for animations");a.push(e.name+(s+1)+".spicaTexture"+(n.textureIndex+1))}})}),[["rotation","Rotation"],["scaleX","Repeat[x]"],["scaleY","Repeat[y]"],["translationX","Offset[x]",!0],["translationY","Offset[y]",!0]].forEach(([t,o,c])=>{if(n[t].length>0){const l=[];let u=0,p=0;for(;p<=e.frames;)l[p]=s.interpolate(n[t][u],n[t][u+1],p),u<n[t].length-1&&n[t][u+1].frame===p&&++u,++p;let h=[],m=[];l.forEach((e,t)=>{h.push(t/s.FPS),c?m.push(-e):m.push(e)}),a.forEach(e=>{let a=new THREE.NumberKeyframeTrack(`${e}${o}`,h.slice(0),m.slice(0),THREE.InterpolateDiscrete);a.spicaConstant=n[t].isConstant,"translationX"===t?a.spicaOrigin=[i.pica.shader.vertex.floats[3*n.textureIndex+1].w]:"translationY"===t?a.spicaOrigin=[i.pica.shader.vertex.floats[3*n.textureIndex+2].w]:"rotation"===t&&(a.spicaOrigin=[0]),r.push(a)})}})}),e.visibility&&e.visibility.transforms.forEach(e=>{let t=this.meshes.filter(t=>t.name===e.mesh)[0];if(!t)return;let n=[],i=[];e.visibility.forEach(e=>{i.push(e.value),n.push(e.frame/s.FPS)}),t.submeshes.forEach((a,s)=>{let o=new THREE.BooleanKeyframeTrack(`${t.name}${s+1}.visible`,n.slice(0),i.slice(0),THREE.InterpolateDiscrete);o.spicaConstant=e.visibility.isConstant,o.spicaOrigin=[!0],r.push(o)})}),e.constant&&e.constant.values.forEach(n=>{let i=this.materials.filter(e=>e.name===n.material)[0];if(!i)return void t.warn("Material not found: "+n.material);let a=[];this.meshes.forEach(e=>{e.submeshes.forEach((i,r)=>{if(i.material===n.material){if(!this.materials.filter(e=>e.name===i.material)[0])return void t.warn("Material not found for animations");a.push(e.name+(r+1))}})});const o=[];["r","g","b","a"].forEach(t=>{let a=0,r=0;for(;r<=e.frames;)o[r]||(o[r]={}),n[t].length>0?o[r][t]=s.interpolate(n[t][a],n[t][a+1],r):o[r][t]=i.constantColors[n.constantIndex][t]/255,a<n[t].length-1&&n[t][a+1].frame===r&&++a,++r});let c=o.map((e,t)=>t/s.FPS),l=[];o.forEach(e=>{l.push(e.r,e.g,e.b,e.a)}),a.forEach(e=>{let t=new THREE.VectorKeyframeTrack(`${e}.spicaConstant${n.constantIndex}`,c.slice(0),l.slice(0),THREE.InterpolateLinear);t.spicaConstant=!1,t.spicaOrigin=[i.constantColors[n.constantIndex].r/255,i.constantColors[n.constantIndex].g/255,i.constantColors[n.constantIndex].b/255,i.constantColors[n.constantIndex].a/255],r.push(t)})});let o=new THREE.AnimationClip(a,e.frames/s.FPS,r);o.spicaHash=e.hash,u.animations.push(o)})}),u.spicaAnimationMixers={time:0,bindings:{},channels:{},pathes:{}},u.spicaPlayAction=function(e,n){n||(n={}),n.channel||(n.channel=t.uuid()),t.is.nil(n.fadings)&&(n.fadings=.2),t.is(n.fadings,Number)&&(n.fadings=[n.fadings]),1===n.fadings.length?n.fadings=[n.fadings[0],n.fadings[0],n.fadings[0]]:2===n.fadings.length&&(n.fadings=[n.fadings[0],n.fadings[1],n.fadings[0]]),t.is.nil(n.priority)&&(n.priority=1),t.is.nil(n.weight)&&(n.weight=1),t.is.nil(n.frame)&&(n.frame=0),t.is.nil(n.paused)&&(n.paused=!1),t.is.nil(n.loop)&&(n.loop=1);let i=u.animations.filter(t=>t.name===e)[0];if(!i)return t.async.reject(new Error("Animation "+e+" not found"));n.fadings[0]>i.duration*n.loop*.1&&(n.fadings[0]=i.duration*n.loop*.1),n.fadings[2]>i.duration*n.loop*.1&&(n.fadings[2]=i.duration*n.loop*.1);let a=u.spicaAnimationMixers.time;return t.async(function(){u.spicaAnimationMixers.channels.hasOwnProperty(n.channel)&&u.spicaAnimationMixers.channels[n.channel]&&u.spicaAnimationMixers.channels[n.channel].forEach(e=>{e.fadeOut(n.fadings[1])});let r=[];i.tracks.forEach(o=>{let c={path:o.name,mixable:/^\.bones\[/.test(o.name),constant:!!o.spicaConstant,priority:n.priority,target:u,key:null,origin:o.spicaOrigin,frame:Math.round(n.frame/s.FPS/i.duration*o.times.length),passed:n.frame/s.FPS,paused:n.paused,times:o.times,units:o.values.length/o.times.length,values:o.values,duration:i.duration,starting:a,action:e,loop:n.loop,weight:n.weight,fadings:n.fadings.slice(0)};u.spicaAnimationMixers.pathes[c.path]?(c.target=u.spicaAnimationMixers.pathes[c.path].target,c.key=u.spicaAnimationMixers.pathes[c.path].key):(c.path.split(/[\.\[\]]+/).filter(e=>e).forEach((e,n,i)=>{if(n<i.length-1)if("bones"===e)c.target=c.target.skeleton.bones;else if(t.is(c.target,Array))c.target=c.target.filter(t=>t.name===e)[0];else if(c.target[e])c.target=c.target[e];else{if(!c.target.children)throw new Error("Not found");c.target=c.target.children.filter(t=>t.name===e)[0]}else c.key=e}),u.spicaAnimationMixers.pathes[c.path]={target:c.target,key:c.key}),u.spicaAnimationMixers.bindings[c.path]||(u.spicaAnimationMixers.bindings[c.path]=[]),u.spicaAnimationMixers.bindings[c.path].push(c),r.push(c)}),u.spicaAnimationMixers.channels.hasOwnProperty(n.channel)||(u.spicaAnimationMixers.channels[n.channel]=[]);let o=a-Date.now()/1e3;u.spicaAnimationMixers.channels[n.channel].push({listeners:[this.next],time:n.frame/s.FPS,paused:n.paused,starting:a,duration:i.duration,loop:n.loop,fadings:n.fadings.slice(0),fadeOut:function(e,n){t.is.nil(this.ending)&&(n||(n=Date.now()/1e3+o),this.starting+this.duration*this.loop-n<e&&(e=this.starting+this.duration*this.loop-n),e>this.duration*this.loop*.1&&(e=this.duration*this.loop*.1),e<0&&(e=0),this.fadings[1]=e,this.ending=u.spicaAnimationMixers.time,r.forEach(t=>{t.ending=this.ending,t.fadings.push(e)}))},stop:function(){this.fadeOut(0)},remove:function(){if(!this.removed){if(this.removed=!0,u.spicaAnimationMixers.channels[n.channel]){let e=u.spicaAnimationMixers.channels[n.channel].indexOf(this);-1!==e&&u.spicaAnimationMixers.channels[n.channel].splice(e,1),0===u.spicaAnimationMixers.channels[n.channel].length&&delete u.spicaAnimationMixers.channels[n.channel]}this.listeners.forEach(e=>{try{e(!t.is.nil(this.ending))}catch(e){t.error(e)}}),r.forEach(e=>{if(u.spicaAnimationMixers.bindings[e.path]){let n=u.spicaAnimationMixers.bindings[e.path].indexOf(e);-1!==n&&u.spicaAnimationMixers.bindings[e.path].splice(n,1),0===u.spicaAnimationMixers.bindings[e.path].length&&(e.origin&&t.delay(()=>{switch(e.key){case"visible":e.target[e.key]=!!e.origin[0];break;case"x":case"y":case"z":case"spicaTexture1Rotation":case"spicaTexture2Rotation":case"spicaTexture3Rotation":e.target[e.key]=e.origin[0];break;case"quaternion":e.target[e.key].set(e.origin[0],e.origin[1],e.origin[2],e.origin[3]);break;case"scale":case"position":e.target[e.key].set(e.origin[0],e.origin[1],e.origin[2]);break;default:e.target[e.key].set(e.origin[0],e.origin[1],e.origin[2],e.origin[3])}}),delete u.spicaAnimationMixers.bindings[e.path])}})}}})})},u.spicaTick=function(e){let n=u.spicaAnimationMixers.time+e;Object.keys(u.spicaAnimationMixers.bindings).forEach(e=>{let i=u.spicaAnimationMixers.bindings[e];if(0===i.length)return;let a=[],r={};i.forEach(e=>{if(!e.paused&&!e.ending){let t=n-e.starting;for(t-=Math.floor(t/e.duration)*e.duration,n-e.starting>e.duration*e.loop&&(t=e.duration),e.passed=t;e.frame>1&&e.times[e.frame-1]>t;)--e.frame;for(;e.frame<e.times.length-1&&e.times[e.frame+1]<t;)++e.frame}let i=1;t.is.nil(e.ending)?n<e.starting+e.fadings[0]?e.fadings[0]>0&&(i=(n-e.starting)/e.fadings[0]):e.starting+e.duration*e.loop-e.fadings[2]<n&&e.fadings[2]>0&&(i=(e.starting+e.duration*e.loop-n)/e.fadings[2]):i=n<e.ending+e.fadings[1]?e.starting+e.fadings[0]<e.ending?1-(n-e.ending)/e.fadings[1]:(e.ending-e.starting)/e.fadings[0]-(n-e.ending)/e.fadings[1]:0,i<0?i=0:i>1&&(i=1),e.fading=i,-1===a.indexOf(e.priority)&&(r[e.priority]=[],a.push(e.priority)),r[e.priority].push(e)}),a.sort((e,t)=>t-e);let s=1,o=0,c=0,l=[],p=null;if([!1,!0].forEach(e=>{let t=0;for(;o<1&&t<a.length;)r[a[t]].forEach(t=>{if(t.constant===e)if(t.mixable){let e=0;for(;e<t.units;){l[e]||(l[e]=0);let n=t.values[t.frame*t.units+e];l[e]+=s*t.weight*t.fading*n,++e}o+=t.fading,c+=s*t.weight*t.fading}else(!p||p[0]===t.priority&&p[1]<t.weight*t.fading&&(p[2]&e)===e)&&(l=t.values.slice(t.frame*t.units,(t.frame+1)*t.units),p=[t.priority,t.weight*t.fading,e],o=1,c=1)}),s=1-o,++t}),o<1&&i[0].origin){if(i[0].mixable){let e=0;for(;e<i[0].units;)l[e]||(l[e]=0),l[e]+=(1-o)*i[0].origin[e],++e;c+=1-o}else l=i[0].origin.slice(0),c=1;o=1}i[0].mixable&&0!==c&&(l=l.map(e=>e/c));let h=i[0].target,m=i[0].key;switch(m){case"position":case"scale":h[m].set(l[0],l[1],l[2]);break;case"quaternion":h[m].set(l[0],l[1],l[2],l[3]);break;case"visible":h[m]=!!l[0];break;case"x":case"y":case"z":case"spicaTexture1Rotation":case"spicaTexture2Rotation":case"spicaTexture3Rotation":h[m]=l[0];break;default:h[m].set(l[0],l[1],l[2],l[3])}}),Object.keys(u.spicaAnimationMixers.channels).forEach(e=>{u.spicaAnimationMixers.channels[e].slice(0).forEach(e=>{if(t.is.nil(e.ending)){if(e.paused)return;if(n-e.starting<=e.duration*e.loop)return}else if(n-e.ending<e.fadings[1])return;e.remove()})}),u.spicaAnimationMixers.time=n},u.spicaDispose=function(){c.forEach(e=>{try{e.dispose()}catch(e){}})},u}})(0,this.$);