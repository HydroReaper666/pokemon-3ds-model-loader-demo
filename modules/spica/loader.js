((t,e)=>{const i=this.TextDecoder,n=require("./pc.js"),r=function(){1===arguments.length&&e.is(arguments[0],Array)?this.files=arguments[0].slice(0):this.files=Array.prototype.slice.call(arguments,0),this.resources=new Map};r.prototype.load=function(t){return t||(t=new n(this)),e.async.all(this.files,function(i){e.async(function(){e.request(i,{responseDataType:"binary"},this.test)}).then(function(e){t.load(new r.Reader(new DataView(e))).pipe(this)}).pipe(this)}).resolve(t)};const h=function(t,e,i){this.buffer=t,this.begin=e,this.begin||(this.begin=0),this.end=this.buffer.byteLength,void 0!==i&&null!==i&&this.begin+i<this.end&&(this.end=this.begin+i),this.index=this.begin};h.prototype.getString=function(t){if(this.index>=this.end)throw new Error("Reader has reach the end of buffer");if(e.is.nil(t))for(t=0;this.index+t<this.end&&0!==this.buffer.getUint8(this.index+t)&&this.index+t<this.buffer.byteLength;)++t;let n=(new i).decode(new Uint8Array(this.buffer.buffer,this.buffer.byteOffset+this.index,t)),r=0;for(;0!==n.charCodeAt(r)&&r<n.length;)++r;return n=n.slice(0,r)},h.prototype.readString=function(t){let i=this.getString(t);return e.is.nil(t)?this.index+=i.length+1:this.index+=t,i},h.prototype.getUint8=function(){if(this.index>=this.end)throw new Error("Reader has reach the end of buffer");return this.buffer.getUint8(this.index)},h.prototype.getUint16=function(){if(this.index+1>=this.end)throw new Error("Reader has reach the end of buffer");return this.buffer.getUint16(this.index,!0)},h.prototype.getUint32=function(){if(this.index+3>=this.end)throw new Error("Reader has reach the end of buffer");return this.buffer.getUint32(this.index,!0)},h.prototype.getInt8=function(){if(this.index>=this.end)throw new Error("Reader has reach the end of buffer");return this.buffer.getInt8(this.index)},h.prototype.getInt16=function(){if(this.index+1>=this.end)throw new Error("Reader has reach the end of buffer");return this.buffer.getInt16(this.index,!0)},h.prototype.getInt32=function(){if(this.index+3>=this.end)throw new Error("Reader has reach the end of buffer");return this.buffer.getInt32(this.index,!0)},h.prototype.readUint8=function(){let t=this.getUint8();return++this.index,t},h.prototype.readUint16=function(){let t=this.getUint16();return this.index+=2,t},h.prototype.readUint32=function(){let t=this.getUint32();return this.index+=4,t},h.prototype.readInt8=function(){let t=this.getInt8();return++this.index,t},h.prototype.readInt16=function(){let t=this.getInt16();return this.index+=2,t},h.prototype.readInt32=function(){let t=this.getInt32();return this.index+=4,t},h.prototype.getFloat32=function(){if(this.index+3>=this.end)throw new Error("Reader has reach the end of buffer");return this.buffer.getFloat32(this.index,!0)},h.prototype.readFloat32=function(){let t=this.getFloat32();return this.index+=4,t},h.prototype.subreader=function(t,i){if(t||(t=0),e.is.nil(i)&&(i=this.end-this.index-t),i>0){if(this.index>=this.end)throw new Error("Reader has reach the end of buffer");if(this.index+t>=this.end)throw new Error("The offset is out of the range of the buffer");if(this.index+t+i>this.end)throw new Error("The end of the slice is out of the range of the buffer")}return new h(this.buffer,this.index+t,i)},h.prototype.skipPadding=function(t,i){for(e.is(i,Number)&&(i=[i]);(this.index-this.begin)%t;){let t=this.readUint8();if(!e.is.nil(i)&&-1===i.indexOf(t))throw new Error("Expected "+i+", but got "+t)}},h.prototype.skip=function(t,i){e.is(i,Number)&&(i=[i]);let n=0;for(;n<t;){let t=this.readUint8();if(!e.is.nil(i)&&-1===i.indexOf(t))throw new Error("Expected "+i+", but got "+t);++n}},Object.defineProperty(h.prototype,"available",{get:function(){return this.end-this.index}}),r.Reader=h,module.exports=r})(0,this.$);